<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>snapshoter</title>

        <script src="https://cdn.jsdelivr.net/npm/react@16.13.1/umd/react.production.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/react-dom@16.13.1/umd/react-dom.production.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.9.6/babel.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/antd@4.2.0/dist/antd.min.js"></script>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/antd@4.2.0/dist/antd.dark.min.css" />
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/material-icons@0.3.1/iconfont/material-icons.min.css" />
        <script src="https://cdn.jsdelivr.net/npm/jimp@0.10.3/browser/lib/jimp.min.js"></script>

        <style>
            body {
                padding: 0;
            }

            .icon {
                font-size: inherit;
                vertical-align: middle;
            }

            .left {
                height: 100vh;
                width: 348px !important;
                min-width: 348px !important;
                overflow: auto;
                position: fixed;
                left: 0;
            }

            .crop {
                height: 203px;
                width: 203px;
                border: solid 1px #303030;
                content: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMkAAADJBAMAAAB76As2AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAD1BMVEX/////AAAAAP//AAD///8Rbtx7AAAAAnRSTlMAAHaTzTgAAAABYktHRACIBR1IAAAAB3RJTUUH5AULFBsZiJKTswAAAAFvck5UAc+id5oAAABSSURBVHja7c9RCcAwDEDBMgWrgxAFK/XvbRr20RHCnYHHGwMAAAAAAAAAAKCcUClZ6WQ1qWSOvZ8r43Rorvv4zF+VVkKlZAUAAAAAAAAAAOCTF/KMAyXmz4bGAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIwLTA1LTExVDIwOjI1OjI4KzAwOjAwNTlOqAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMC0wNS0xMVQyMDoyNToyOCswMDowMERk9hQAAAAZdEVYdFNvZnR3YXJlAEFkb2JlIEltYWdlUmVhZHlxyWU8AAAAAElFTkSuQmCC');
            }

            .right {
                margin-left: 348px;
            }

            .header {
                position: fixed;
                width: 100%;
                height: 32px;
                background: black;
            }

            .content {
                margin-top: 32px;
                padding-bottom: 10px;
                overflow-x: scroll;
            }

            .img {
                max-width: none;
                max-height: none;
            }

            .font-preview-container {
                border: 1px solid #434343;
                height: 32px;
                width: 100%;
            }

            .font-preview {
                height: 100%;
                width: 100%;
                object-fit: contain;
            }

            .rubberband {
                position: absolute;
                width: 0;
                height: 0;
                border: 1px dashed blue;
                background: blue;
                opacity: 0.3;
            }
        </style>

        <script type="text/babel">
            const { Row, Col, Layout, Space, Menu, Tabs, Divider, Table, Input, Button, Dropdown, message, Select } = antd;
            const { Header, Content, Footer, Sider } = Layout;
            const { TextArea } = Input;
            const { TabPane } = Tabs;
            const { Option } = Select;

            const vscode = acquireVsCodeApi();

            window.onload = () => {
                ReactDOM.render(<App />, document.getElementById('app'));
            };

            function colorHex(color) {
                return '0x' + `00000000${color.toString(16).slice(0, -2).toUpperCase()}`.slice(-6);
            }

            function copyText(text) {
                vscode.postMessage({ command: 'copy', payload: text });
                message.info(`${text.slice(0, 30)}${text.length > 30 ? '...' : ''} 已复制到剪贴板`);
            }

            function simpleRotate(jimp, deg) {
                function rotate90degrees(bitmap, dstBuffer, clockwise) {
                    const dstOffsetStep = clockwise ? -4 : 4;
                    let dstOffset = clockwise ? dstBuffer.length - 4 : 0;

                    let tmp;
                    let x;
                    let y;
                    let srcOffset;

                    for (x = 0; x < bitmap.width; x++) {
                        for (y = bitmap.height - 1; y >= 0; y--) {
                            srcOffset = (bitmap.width * y + x) << 2;
                            tmp = bitmap.data.readUInt32BE(srcOffset, true);
                            dstBuffer.writeUInt32BE(tmp, dstOffset, true);
                            dstOffset += dstOffsetStep;
                        }
                    }
                }

                let steps = Math.round(deg / 90) % 4;
                steps += steps < 0 ? 4 : 0;

                if (steps === 0) {
                    return jimp;
                }

                const srcBuffer = jimp.bitmap.data;
                const len = srcBuffer.length;
                const dstBuffer = Buffer.allocUnsafe(len);

                let tmp;

                if (steps === 2) {
                    // Upside-down
                    for (let srcOffset = 0; srcOffset < len; srcOffset += 4) {
                        tmp = srcBuffer.readUInt32BE(srcOffset, true);
                        dstBuffer.writeUInt32BE(tmp, len - srcOffset - 4, true);
                    }
                } else {
                    // Clockwise or counter-clockwise rotation by 90 degree
                    rotate90degrees(jimp.bitmap, dstBuffer, steps === 1);

                    tmp = jimp.bitmap.width;
                    jimp.bitmap.width = jimp.bitmap.height;
                    jimp.bitmap.height = tmp;
                }

                jimp.bitmap.data = dstBuffer;
                return jimp;
            }

            const CursorInfo = props => {
                const { crop, cursor } = props;
                const columns = [
                    {
                        dataIndex: 'name',
                        align: 'right',
                        width: '50px',
                    },
                    {
                        dataIndex: 'value',
                        width: '90px',
                        render: (text, record, index) => {
                            if (index === 3) {
                                return {
                                    props: {
                                        style: {
                                            background: `#${text.slice(2)}`,
                                        },
                                    },
                                };
                            } else {
                                return text;
                            }
                        },
                    },
                ];
                const dataSource = [
                    {
                        name: 'X',
                        value: cursor.x,
                    },
                    {
                        name: 'Y',
                        value: cursor.y,
                    },
                    {
                        name: '颜色',
                        value: cursor.c,
                    },
                    {
                        name: '预览',
                        value: cursor.c,
                    },
                ];

                return (
                    <div>
                        <Divider orientation='left' plain>
                            <i class='material-icons icon'>gps_fixed</i> 光标信息
                        </Divider>
                        <Row>
                            <Col span={14}>
                                <img className='crop' style={{ backgroundImage: `url(${crop})` }} alt='' />
                            </Col>
                            <Col span={10}>
                                <Table showHeader={false} bordered={true} size='small' pagination={false} dataSource={dataSource} columns={columns} />
                            </Col>
                        </Row>
                    </div>
                );
            };

            const ColorRecord = props => {
                const { colors, setColorRecord } = props;
                const columns = [
                    {
                        title: '坐标',
                        width: '90px',
                        dataIndex: 'position',
                        onCell: record => {
                            return {
                                onClick: () => {
                                    if (record.color) {
                                        copyText(record.position);
                                    }
                                },
                            };
                        },
                    },
                    {
                        title: '颜色',
                        width: '90px',
                        dataIndex: 'color',
                        onCell: record => {
                            return {
                                onClick: () => {
                                    if (record.color) {
                                        copyText(record.color);
                                    }
                                },
                            };
                        },
                    },
                    {
                        title: '预览',
                        width: '50px',
                        dataIndex: 'preview',
                        render: (text, record, index) => {
                            if (record.position) {
                                return {
                                    props: {
                                        style: {
                                            background: `#${text.slice(2)}`,
                                        },
                                    },
                                };
                            }
                        },
                    },
                    {
                        title: '操作',
                        render: record => {
                            if (record.position) {
                                return (
                                    <div>
                                        <a>Delete</a>
                                    </div>
                                );
                            }
                        },
                        onCell: (record, index) => {
                            return {
                                onClick: () => {
                                    const copy = [...colors];
                                    copy.splice(index, 1);
                                    copy.push({
                                        position: '',
                                        color: '',
                                        preview: '',
                                    });
                                    setColorRecord(copy);
                                },
                            };
                        },
                    },
                ];
                return (
                    <div>
                        <Divider orientation='left' plain>
                            <i class='material-icons icon'>colorize</i> 颜色记录
                        </Divider>
                        <Table size='small' bordered={true} pagination={false} dataSource={colors} columns={columns} />
                    </div>
                );
            };

            // const Binarization = props => {
            //     return;

            //     const { jimp, onBinarization, onReset, cursor, done } = props;
            //     const [colors, setColors] = React.useState('0xFFFFFF');
            //     const [fuzzy, setFuzzy] = React.useState(90);

            //     React.useEffect(() => {
            //         function onKeyDown(e) {
            //             if (e.key === '5') {
            //                 if (colors.trim().endsWith(',')) {
            //                     setColors(`${colors.trim().slice(0, -1)},${cursor.c}`);
            //                 } else {
            //                     const tmp = colors.trim().split(',');
            //                     tmp.pop();
            //                     tmp.push(cursor.c);
            //                     setColors(tmp.join(','));
            //                 }
            //             }
            //         }
            //         window.addEventListener('keydown', onKeyDown);
            //         return () => {
            //             window.removeEventListener('keydown', onKeyDown);
            //         };
            //     });

            //     function onColorsChange(e) {
            //         setColors(e.target.value);
            //     }

            //     function onFuzzyChange(e) {
            //         setFuzzy(e.target.value);
            //     }

            //     function onStart() {
            //         const _colors = colors.split(',').map(item => Jimp.intToRGBA(parseInt(item.trim() + 'ff')));
            //         const _fuzzy = parseInt(fuzzy);
            //         const copy = jimp.clone();
            //         copy.scan(0, 0, jimp.bitmap.width, jimp.bitmap.height, (x, y, index) => {
            //             const r = copy.bitmap.data[index + 0];
            //             const g = copy.bitmap.data[index + 1];
            //             const b = copy.bitmap.data[index + 2];
            //             if (
            //                 _colors.some(item => {
            //                     if (_fuzzy === 100) {
            //                         return item.r === r && item.g === g && item.b === b;
            //                     } else {
            //                         const diff =
            //                             Math.sqrt(Math.pow(item.r - r, 2) + Math.pow(item.g - g, 2) + Math.pow(item.b - b, 2)) /
            //                             Math.sqrt(Math.pow(255, 2) + Math.pow(255, 2) + Math.pow(255, 2));
            //                         return (1 - diff) * 100 > _fuzzy;
            //                     }
            //                 })
            //             ) {
            //                 copy.setPixelColor(0x000000ff, x, y);
            //             } else {
            //                 copy.setPixelColor(0xffffffff, x, y);
            //             }
            //         });
            //         onBinarization(copy, colors, fuzzy);
            //     }

            //     return (
            //         <div>
            //             <Divider orientation='left' plain>
            //                 <i class='material-icons icon'>filter_b_and_w</i> 二值化
            //             </Divider>
            //             <Row>
            //                 <Col span={10}>
            //                     <Input value={colors} onChange={onColorsChange} placeHolder='颜色过滤'></Input>
            //                 </Col>
            //                 <Col span={6}>
            //                     <Input value={fuzzy} onChange={onFuzzyChange} placeHolder='精度'></Input>
            //                 </Col>
            //                 <Col span={4}>
            //                     <Button style={{ width: '100%' }} onClick={onStart} disabled={done}>
            //                         开始
            //                     </Button>
            //                 </Col>
            //                 <Col span={4}>
            //                     <Button style={{ width: '100%' }} onClick={onReset} disabled={!done}>
            //                         重置
            //                     </Button>
            //                 </Col>
            //             </Row>
            //         </div>
            //     );
            // };

            // const CodeMaker = props => {
            //     const { colorGenerator, onCodeGeneratorClear, onCodeGeneratorPop, binarization, onSelectFont } = props;
            //     return (
            //         <div>
            //             <Divider orientation='left' plain>
            //                 <i class='material-icons icon'>code</i> 代码生成器
            //             </Divider>
            //             <Tabs defaultActiveKey='1' type='card' size='small'>
            //                 <TabPane
            //                     tab={
            //                         <span>
            //                             <i class='material-icons icon'>palette</i> 找色
            //                         </span>
            //                     }
            //                     key='1'
            //                 >
            //                     <CodeGenerator colors={colorGenerator} onClear={onCodeGeneratorClear} onPop={onCodeGeneratorPop} />
            //                 </TabPane>
            //                 <TabPane
            //                     tab={
            //                         <span>
            //                             <i class='material-icons icon'>font_download</i> 字库
            //                         </span>
            //                     }
            //                     key='2'
            //                 >
            //                     <FontLib
            //                         binarization={{
            //                             done: binarization.backup !== null,
            //                             colors: binarization.colors,
            //                             fuzzy: binarization.fuzzy,
            //                         }}
            //                         onSelect={onSelectFont}
            //                     />
            //                 </TabPane>
            //             </Tabs>
            //         </div>
            //     );
            // };

            const CodeGenerator = props => {
                const defaultTemplates = ["{'undefined',{$pointList}}", "{'undefined',{$firstPoint-c,'$delta'}}", '{$pointList}'];

                const { colors, cRef } = props;
                const [code, setCode] = React.useState('');
                const [category, setCategory] = React.useState('0');
                const [templates, setTemplates] = React.useState(defaultTemplates);
                const [template, setTemplate] = React.useState(templates[category]);

                React.useEffect(() => {
                    window.addEventListener('message', async event => {
                        const message = event.data;
                        if (message.command === 'loadTemplate') {
                            if (message.payload) {
                                const preSave = JSON.parse(message.payload);
                                setTemplates(preSave);
                                setTemplate(preSave[category]);
                            }
                        }
                    });
                    vscode.postMessage({ command: 'loadTemplate' });
                }, []);

                function handleTemplateChange(e) {
                    setTemplate(e.target.value);
                }

                function handleSave() {
                    const newTemplates = [...templates];
                    newTemplates[category] = template;
                    setTemplates(newTemplates);
                    vscode.postMessage({
                        command: 'saveTemplate',
                        payload: JSON.stringify(templates),
                    });
                }

                function handleRestoreDefault() {
                    setTemplate(defaultTemplates[category]);
                    setTemplates(defaultTemplates);
                    vscode.postMessage({
                        command: 'saveTemplate',
                        payload: JSON.stringify(defaultTemplates),
                    });
                }

                function handleGenerate() {
                    const trueColors = colors.filter(item => item.color);
                    if (trueColors.length == 0) {
                        return;
                    }

                    const pointList = trueColors.map(item => {
                        return {
                            x: item.position.split(',')[0],
                            y: item.position.split(',')[1],
                            c: item.color,
                        };
                    });
                    const firstPoint = pointList[0];
                    const pointListInString = pointList.map(item => {
                        return `{${item.x},${item.y},${item.c}}`;
                    });
                    const delta = pointList.map(item => {
                        return `${item.x - firstPoint.x}|${item.y - firstPoint.y}|${item.c}`;
                    });
                    delta.shift();

                    const code = template
                        .replace(/\$pointList/g, pointListInString.join(','))
                        .replace(/\$delta/g, delta.join(','))
                        .replace(/\$firstPoint-c/g, firstPoint.c)
                        .replace(/\$firstPoint-x/g, firstPoint.x)
                        .replace(/\$firstPoint-y/g, firstPoint.y);

                    setCode(code);
                    copyText(code);
                }

                function handleCategoryChange(e) {
                    setCategory(e);
                    setTemplate(templates[e]);
                }

                React.useImperativeHandle(cRef, () => ({ handleGenerate }));

                const templatePlaceHolder = '$pointList => 比色数据表\n$firstPoint-x/y/c => 首点x坐标/y坐标/颜色值\n$delta => 找色数据差值';

                return (
                    <div>
                        <Divider orientation='left' plain>
                            <i class='material-icons icon'>code</i> 代码生成器
                        </Divider>
                        <TextArea value={code} rows={4} readOnly placeHolder='代码输出' />
                        <Button block onClick={handleGenerate}>
                            生成代码
                        </Button>
                        <TextArea rows={4} value={template} onChange={handleTemplateChange} placeHolder={templatePlaceHolder} />
                        <Select style={{ width: '34%' }} defaultValue={category} onChange={handleCategoryChange}>
                            <Option value='0'>模板1</Option>
                            <Option value='1'>模板2</Option>
                            <Option value='2'>模板3</Option>
                        </Select>
                        <Button style={{ width: '33%' }} onClick={handleSave}>
                            保存模板
                        </Button>
                        <Button style={{ width: '33%' }} onClick={handleRestoreDefault}>
                            恢复默认
                        </Button>
                    </div>
                );
            };

            // const FontLib = props => {
            //     const { binarization, onSelect } = props;
            //     const [fonts, setFonts] = React.useState([]);
            //     const [code, setCode] = React.useState('');

            //     function onTextChange(index) {
            //         return e => {
            //             const copy = [...fonts];
            //             copy[index].text = e.target.value;
            //             setFonts(copy);
            //         };
            //     }

            //     const onClick = index => {
            //         return () => {
            //             onSelect(data => {
            //                 const copy = [...fonts];
            //                 copy[index].data = data;
            //                 setFonts(copy);
            //             });
            //         };
            //     };

            //     const onDelete = index => {
            //         return () => {
            //             const copy = [...fonts];
            //             copy.splice(index, 1);
            //             setFonts(copy);
            //         };
            //     };

            //     function onAdd() {
            //         if (!binarization.done) {
            //             message.error('请先调整二值化参数至要找的字清晰');
            //             return;
            //         }
            //         setFonts([
            //             ...fonts,
            //             {
            //                 text: '',
            //                 data: '',
            //                 colors: binarization.colors
            //                     .split(',')
            //                     .map(item => item.trim())
            //                     .join(', '),
            //                 fuzzy: binarization.fuzzy,
            //             },
            //         ]);
            //     }

            //     function onGenerate() {
            //         if (fonts.some(item => !item.text || !item.data)) {
            //             message.error('键值不能为空');
            //             return;
            //         }
            //         const table = fonts.map(item => `  {'${item.text}', {${item.colors}}, ${item.fuzzy}, '${item.data}'}`).join(', \n');
            //         const code = `{\n${table}\n}`;
            //         setCode(code);
            //         copyText(code);
            //     }

            //     return (
            //         <div>
            //             {fonts.map((item, index) => (
            //                 <Row>
            //                     <Col span={4}>
            //                         <Input placeHolder='字键' value={item.text} onChange={onTextChange(index)}></Input>
            //                     </Col>
            //                     <Col span={2}>
            //                         <div className='font-preview-container'>
            //                             <img className='font-preview' src={'data:image/png;base64,' + item.data} alt='' />
            //                         </div>
            //                     </Col>
            //                     <Col span={14}>
            //                         <Input placeHolder='字值 (点击后框选数据)' readOnly value={item.data} onClick={onClick(index)}></Input>
            //                     </Col>
            //                     <Col span={4}>
            //                         <Button type='danger' onClick={onDelete(index)}>
            //                             删除
            //                         </Button>
            //                     </Col>
            //                 </Row>
            //             ))}
            //             <Button block onClick={onAdd}>
            //                 添加
            //             </Button>
            //             <TextArea value={code} rows={4} readOnly placeHolder='字库输出' />
            //             <Button disabled={fonts.length === 0} block type='primary' onClick={onGenerate}>
            //                 生成字库
            //             </Button>
            //         </div>
            //     );
            // };

            const App = () => {
                const [image, setImage] = React.useState({ jimp: null, base64: '', deg: 0 });
                const [binarization, setBinarization] = React.useState({ backup: null, colors: [], fuzzy: 0 });
                const [crop, setCrop] = React.useState('');
                const [cursor, setCursor] = React.useState({ x: -1, y: -1, c: '0x000000' });
                const [cut, setCut] = React.useState({ enabled: false, clientX: -1, clientY: -1, imageX: -1, imageY: -1, div: null, callback: data => {} });
                const records = [];
                for (let i = 0; i < 9; i++) {
                    records.push({ position: '', color: '', preview: '' });
                }
                const [colorRecord, setColorRecord] = React.useState(records);
                const [colorGenerator, setColorGenerator] = React.useState([]);
                const contentRef = React.useRef(null);
                const codeGeneratorRef = React.useRef(null);

                async function initImage(jimp, deg) {
                    setImage({
                        jimp: jimp,
                        base64: await jimp.getBase64Async(Jimp.MIME_PNG),
                        deg: deg,
                    });
                }

                React.useEffect(() => {
                    resetCrop();
                    window.addEventListener('message', async event => {
                        const message = event.data;
                        if (message.command === 'init') {
                            setBinarization({
                                backup: null,
                                colors: [],
                                fuzzy: 0,
                            });
                            initImage(await Jimp.read(Buffer.from(message.payload, 'base64')), 0);
                        }
                    });
                    vscode.postMessage({ command: 'init' });
                }, []);

                React.useEffect(() => {
                    function setRecord(n) {
                        if (cursor.x !== -1 && cursor.y !== -1) {
                            const copy = [...colorRecord];
                            copy[n - 1].position = `${cursor.x},${cursor.y}`;
                            copy[n - 1].color = cursor.c;
                            copy[n - 1].preview = cursor.c;
                            setColorRecord(copy);
                        }
                    }

                    function addRecord() {
                        if (cursor.x !== -1 && cursor.y !== -1 && !cut.div) {
                            const copy = [...colorRecord];
                            for (let i = 0; i < copy.length; i++) {
                                if (!copy[i].position || i === copy.length - 1) {
                                    copy[i].position = `${cursor.x},${cursor.y}`;
                                    copy[i].color = cursor.c;
                                    copy[i].preview = cursor.c;
                                    break;
                                }
                            }
                            setColorRecord(copy);
                        }
                    }

                    function clearAllRecord() {
                        if (cursor.x !== -1 && cursor.y !== -1) {
                            let records = [];
                            for (let i = 0; i < 9; i++) {
                                records.push({
                                    position: '',
                                    color: '',
                                    preview: '',
                                });
                            }
                            setColorRecord(records);
                        }
                    }

                    function addCodeGenerator() {
                        if (cursor.x !== -1 && cursor.y !== -1) {
                            setColorGenerator([
                                ...colorGenerator,
                                {
                                    x: cursor.x,
                                    y: cursor.y,
                                    c: cursor.c,
                                },
                            ]);
                        }
                    }

                    function onKeyDown(e) {
                        if (['1', '2', '3', '4', '5', '6', '7', '8', '9'].includes(e.key)) {
                            setRecord(parseInt(e.key));
                        } else if (e.key === 'w') {
                            updateCursor(cursor.x, cursor.y - 1);
                        } else if (e.key === 's') {
                            updateCursor(cursor.x, cursor.y + 1);
                        } else if (e.key === 'a') {
                            updateCursor(cursor.x - 1, cursor.y);
                        } else if (e.key === 'd') {
                            updateCursor(cursor.x + 1, cursor.y);
                        } else if (e.key === 'z') {
                            clearAllRecord();
                        } else if (e.key === 'f') {
                            codeGeneratorRef.current.handleGenerate();
                        }
                    }

                    window.addEventListener('keydown', onKeyDown);
                    window.addEventListener('click', addRecord);
                    window.addEventListener('contextmenu', clearAllRecord);

                    return () => {
                        window.removeEventListener('keydown', onKeyDown);
                        window.removeEventListener('click', addRecord);
                        window.removeEventListener('contextmenu', clearAllRecord);
                    };
                });

                function resetCrop() {
                    new Jimp(203, 203, 0x000000ff, (_, crop) => {
                        crop.getBase64(Jimp.MIME_PNG, (_, v) => {
                            setCrop(v);
                        });
                    });
                }

                function updateCursor(x, y) {
                    if (x < 0 || y < 0 || x >= image.jimp.bitmap.width || y >= image.jimp.bitmap.height) {
                        return;
                    }
                    setCursor({
                        x: x,
                        y: y,
                        c: colorHex(image.jimp.getPixelColor(x, y)),
                    });

                    new Jimp(11, 11, 0x000000ff, (_, crop) => {
                        for (let i = -5; i <= 5; ++i) {
                            for (let j = -5; j <= 5; ++j) {
                                const x1 = x + i;
                                const y1 = y + j;
                                if (x1 >= 0 && x1 < image.jimp.bitmap.width && y1 >= 0 && y1 < image.jimp.bitmap.height) {
                                    crop.setPixelColor(image.jimp.getPixelColor(x1, y1), i + 5, j + 5);
                                }
                            }
                        }
                        crop.resize(203, 203, Jimp.RESIZE_NEAREST_NEIGHBOR).getBase64(Jimp.MIME_PNG, (_, v) => {
                            setCrop(v);
                        });
                    });
                }

                function onMouseDown(e) {
                    if (!cut.enabled) {
                        return;
                    }

                    const clientX = e.clientX + contentRef.current.scrollLeft;
                    const clientY = e.clientY + window.pageYOffset;

                    const div = document.createElement('div');
                    div.className = 'rubberband';
                    div.style.left = `${e.clientX}px`;
                    div.style.top = `${clientY}px`;
                    contentRef.current.appendChild(div);

                    setCut({
                        ...cut,
                        enabled: false,
                        clientX: e.clientX,
                        clientY: clientY,
                        imageX: cursor.x,
                        imageY: cursor.y,
                        div: div,
                    });
                }

                function onMouseMove(e) {
                    const clientX = e.clientX + contentRef.current.scrollLeft;
                    const clientY = e.clientY + window.pageYOffset;

                    updateCursor(clientX - e.target.offsetLeft, clientY - e.target.offsetTop);

                    if (cut.div) {
                        cut.div.style.left = `${Math.min(e.clientX, cut.clientX)}px`;
                        cut.div.style.top = `${Math.min(clientY, cut.clientY)}px`;
                        cut.div.style.width = `${Math.abs(cut.clientX - e.clientX)}px`;
                        cut.div.style.height = `${Math.abs(cut.clientY - clientY)}px`;
                    }
                }

                function onMouseUp() {
                    if (!cut.div) {
                        return;
                    }

                    cut.div.parentElement.removeChild(cut.div);
                    cut.div = null;
                    const x = Math.min(cursor.x, cut.imageX);
                    const y = Math.min(cursor.y, cut.imageY);
                    const w = Math.abs(cursor.x - cut.imageX);
                    const h = Math.abs(cursor.y - cut.imageY);

                    image.jimp
                        .clone()
                        .crop(x, y, w, h)
                        .getBase64(Jimp.MIME_PNG, (_, v) => {
                            cut.callback(v.slice(22));
                        });
                }

                function onMouseLeave() {
                    if (cut.div) {
                        return;
                    }

                    setCursor({
                        x: -1,
                        y: -1,
                        c: '0x000000',
                    });

                    resetCrop();
                }

                function onBinarization(jimp, colors, fuzzy) {
                    if (!binarization.backup) {
                        setBinarization({
                            ...binarization,
                            backup: image,
                            colors: colors,
                            fuzzy: fuzzy,
                        });
                        initImage(jimp, image.deg);
                    }
                }

                function onReset() {
                    if (binarization.backup) {
                        initImage(simpleRotate(binarization.backup.jimp.clone(), 360 - binarization.backup.deg + image.deg), image.deg);
                        setBinarization({
                            ...binarization,
                            backup: null,
                        });
                    }
                }

                function onSnapshot() {
                    vscode.postMessage({ command: 'snapshot' });
                }

                function onOpenLocal() {
                    vscode.postMessage({ command: 'openLocal' });
                }

                function onSaveAs() {
                    image.jimp.getBase64(Jimp.MIME_PNG, (_, v) => {
                        vscode.postMessage({
                            command: 'saveImage',
                            payload: v.slice(22),
                        });
                    });
                }

                function onCut() {
                    setCut({
                        ...cut,
                        enabled: true,
                        callback: data => {
                            vscode.postMessage({
                                command: 'saveImage',
                                payload: data,
                            });
                        },
                    });
                }

                function onSelectFont(f) {
                    setCut({
                        ...cut,
                        enabled: true,
                        callback: data => {
                            f(data);
                        },
                    });
                }

                function onRotate(e) {
                    initImage(simpleRotate(image.jimp.clone(), 360 - image.deg + parseInt(e.key)), parseInt(e.key));
                }

                return (
                    <Layout>
                        <Sider className='left' theme='dark'>
                            <CursorInfo crop={crop} cursor={cursor} />
                            <ColorRecord colors={colorRecord} setColorRecord={setColorRecord} />
                            <CodeGenerator cRef={codeGeneratorRef} colors={colorRecord} />
                        </Sider>
                        <Layout className='right'>
                            <div className='header'>
                                <Button onClick={onSnapshot}>
                                    <i class='material-icons icon'>satellite</i> 远程截图
                                </Button>
                                <Button onClick={onOpenLocal}>
                                    <i class='material-icons icon'>insert_photo</i> 本地图片
                                </Button>
                                <Button onClick={onSaveAs}>
                                    <i class='material-icons icon'>save</i> 另存为
                                </Button>
                                <Button onClick={onCut}>
                                    <i class='material-icons icon'>crop</i> 裁剪
                                </Button>
                                <Dropdown
                                    overlay={
                                        <Menu onClick={onRotate}>
                                            <Menu.Item key='0'>0度</Menu.Item>
                                            <Menu.Item key='90'>90度</Menu.Item>
                                            <Menu.Item key='180'>180度</Menu.Item>
                                            <Menu.Item key='270'>-90度</Menu.Item>
                                        </Menu>
                                    }
                                >
                                    <Button>
                                        <i class='material-icons icon'>crop_rotate</i> 旋转
                                    </Button>
                                </Dropdown>
                            </div>
                            <div className='content' ref={contentRef}>
                                <img
                                    className='img'
                                    src={image.base64}
                                    alt=''
                                    draggable='false'
                                    onMouseDown={onMouseDown}
                                    onMouseMove={onMouseMove}
                                    onMouseLeave={onMouseLeave}
                                    onMouseUp={onMouseUp}
                                />
                            </div>
                        </Layout>
                    </Layout>
                );
            };
        </script>
    </head>
    <body>
        <div id="app"></div>
    </body>
</html>
